# 02. 의존성 역전하기 
## 단일 책임 원칙
- 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다. 
- 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서 전혀 신경 쓸 필요가 없다. 

## 의존성 역전 원칙
- DIP: 코드상 어떤 의존성이든 그 방향을 바꿀 수 있다. 
- 도메인 게층에 리포지토리에 대한 인터페이스를 만들고, 그 구현은 영속성 계층에서한다. 

## 클린 아키텍처
![](https://techblog.woowahan.com/wp-content/uploads/img/2019-10-02/the-clean-architecture.png)
- 비즈니스 규칙은 프레임워크, db, ui 등으로부터 독립적일 수 있다. 
- 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함
- dip로 모든 의존성이 도메인을 향하게
- 대신 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수 해야한다.
- 계층간 모델

## 육각형 아키텍처 (헥사고날 아키텍처)
![](https://images.velog.io/images/nkjang/post/83b5027f-f98e-4b9a-a4ef-7acf88d79d33/image.png)
- 육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스 존재
- 모든 의존성은 코어를 향한다.
- input 어댑터는 주도하는 어댑터, output 어댑터는 주도되는 어댑터
- 코어와 어댑터 간 통신은 애플리케이션 코어가 각각의 포트를 제공한다. 
- 포트와 어댑터 아키텍처

# 03. 코드 구성하기 
- 송금하기 유스케이스
## 계층으로 구성하기
- 애플리케이션의 기능 조각이나 특성을 구분짓는 패키지 경계가 없다. 
- 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다. 

## 아키텍처적으로 표현력 있는 패키지 구조
- 육각형 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터
```
ㄴ adapter
    ㄴ in
    ㄴ out
ㄴ domain
ㄴ application
    ㄴ port
        ㄴ in
        ㄴ out
```
- 어댑터 코드를 자체 패키지로 이동시키면 필요한 경우 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다. 
- DDD 개념에 직접적으로 대응시킬 수 있다. 
- 유지보수, 의사소통, 개발이 수월해진다.

## 의존성 주입의 역할
- 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않게 하기 위해 dip
- 


# 06. 영속성 어댑터 구현하기
## 의존성 역전
- 육각형 아키텍처에서 영속성 어댑터는 '주도되는', '아웃고잉' 어댑터
- 포트는 영속성 문제에 신경쓰지 않고 도메인 코드를 개발하기 위해 추가한 계층이다.


## 영속성 어댑터의 책임
- 영속성 어댑터는 포트 인터페이스를 통해 입력 받는다. 
- 그 후 입력 모델로 매핑한다. ex) jpa
- 핵심은 영속성 어댑터의 입력 모델이 영속성 어댑터 내부에 있는 것이 아니라 애플리케이션 코어에 있다.
- 때문에 영속성 어댑터 내부의 변경이 애플리케이션 코어에 영향을 미치지 않는다. 
- 응답 포트에 정의된 출력 모델로 매핑해 반환한다. 
- 출력 모델이 영속성 어댑터가 아닌 애플리케이션 코어에 있다는 것이 중요.
- 입출력 모델이 영속성 어댑터가 아닌 애플리케이션 코어에 있다. 

## 포트 인터페이스 나누기
> 필요없는 화물을 운반하는 무언가에 의존하고 있으면 예상하지 못했던 문제가 생길 수 있다. 

- ISP: 클라이언트가 자신이 필요로하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야한다. 
- 포트 하나 당 하나의 메서드
- 하지만 응집성이 놉을 경우 하나의 포트에 몇개의 메서드가 있을 수 있다.

## 영속성 어댑터 나누기
- 영속성 연산이 필요한 도메인 클래스 (DDD에서의 애그리거트) 하나당 영속성 어댑터를 구현하는 방식
- 여러개의 바운디드 컨텍스트의 영속성 요구사항을 분리하기 좋은 ㅌ대
- 